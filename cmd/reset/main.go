package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type structInfo struct {
	Name   string
	Fields []fieldInfo
}

type fieldInfo struct {
	Name string
	Kind string // primitive, slice, map, pointer
	Type string // имя типа (для primitive / pointer)
}

type packageInfo struct {
	Package string
	Structs []structInfo
}

func main() {
	root, err := os.Getwd()
	fmt.Println(root)
	if err != nil {
		panic(err)
	}

	_ = filepath.WalkDir(root, func(path string, d os.DirEntry, err error) error {
		if err != nil || !d.IsDir() {
			return nil
		}
		processDir(path)
		return nil
	})
}

func processDir(dir string) {
	fset := token.NewFileSet()

	pkgs, err := parser.ParseDir(
		fset,
		dir,
		func(fi os.FileInfo) bool {
			name := fi.Name()
			return strings.HasSuffix(name, ".go") &&
				!strings.HasSuffix(name, "_test.go") &&
				!strings.HasSuffix(name, ".gen.go")
		},
		parser.ParseComments,
	)
	if err != nil || len(pkgs) == 0 {
		return
	}

	for _, pkg := range pkgs {
		pkgInfo := packageInfo{
			Package: pkg.Name,
		}

		for _, file := range pkg.Files {
			for _, decl := range file.Decls {
				gen, ok := decl.(*ast.GenDecl)
				if !ok || gen.Tok != token.TYPE || !hasResetComment(gen.Doc) {
					continue
				}

				for _, spec := range gen.Specs {
					ts, ok := spec.(*ast.TypeSpec)
					if !ok {
						continue
					}

					st, ok := ts.Type.(*ast.StructType)
					if !ok {
						continue
					}

					si := structInfo{Name: ts.Name.Name}

					for _, f := range st.Fields.List {
						if len(f.Names) == 0 {
							continue
						}
						si.Fields = append(si.Fields, parseField(f))
					}

					pkgInfo.Structs = append(pkgInfo.Structs, si)
				}
			}
		}

		if len(pkgInfo.Structs) > 0 {
			generate(dir, pkgInfo)
		}
	}
}

func hasResetComment(cg *ast.CommentGroup) bool {
	if cg == nil {
		return false
	}
	for _, c := range cg.List {
		if strings.Contains(c.Text, "generate:reset") {
			return true
		}
	}
	return false
}

func parseField(f *ast.Field) fieldInfo {
	name := f.Names[0].Name

	switch t := f.Type.(type) {
	case *ast.Ident:
		return fieldInfo{name, "primitive", t.Name}

	case *ast.ArrayType:
		return fieldInfo{name, "slice", ""}

	case *ast.MapType:
		return fieldInfo{name, "map", ""}

	case *ast.StarExpr:
		if id, ok := t.X.(*ast.Ident); ok {
			return fieldInfo{name, "pointer", id.Name}
		}
	}

	return fieldInfo{name, "unknown", ""}
}

func generate(dir string, pkg packageInfo) {
	tpl := template.Must(template.New("reset").
		Funcs(template.FuncMap{
			"zero": zeroValue,
			"recv": receiver,
		}).
		Parse(resetTemplate))

	var b strings.Builder
	if err := tpl.Execute(&b, pkg); err != nil {
		panic(err)
	}

	path := filepath.Join(dir, "reset.gen.go")
	_ = os.WriteFile(path, []byte(b.String()), 0644)
}

func receiver(name string) string {
	return strings.ToLower(name[:1])
}

func zeroValue(t string) string {
	switch t {
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64":
		return "0"
	case "string":
		return `""`
	case "bool":
		return "false"
	default:
		return t + "{}"
	}
}

const resetTemplate = `// Code generated by reset generator. DO NOT EDIT.
package {{.Package}}

{{range .Structs}}
{{$struct := .}}
func ({{recv .Name}} *{{.Name}}) Reset() {
	if {{recv .Name}} == nil {
		return
	}

	{{range .Fields}}
	{{- if eq .Kind "primitive" }}
	{{recv $struct.Name}}.{{.Name}} = {{zero .Type}}
	{{- else if eq .Kind "slice" }}
	{{recv $struct.Name}}.{{.Name}} = {{recv $struct.Name}}.{{.Name}}[:0]
	{{- else if eq .Kind "map" }}
	clear({{recv $struct.Name}}.{{.Name}})
	{{- else if eq .Kind "pointer" }}
	if {{recv $struct.Name}}.{{.Name}} != nil {
		*{{recv $struct.Name}}.{{.Name}} = {{zero .Type}}
		if r, ok := interface{}({{recv $struct.Name}}.{{.Name}}).(interface{ Reset() }); ok {
			r.Reset()
		}
	}
	{{- end}}
	{{end}}
}
{{end}}
`
