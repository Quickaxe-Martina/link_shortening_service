package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

const marker = "generate:reset"

func zeroValue(expr, typ string) string {
	switch typ {
	case "int", "int64", "int32", "uint", "uint64":
		return fmt.Sprintf("\t%s = 0\n", expr)
	case "string":
		return fmt.Sprintf("\t%s = \"\"\n", expr)
	case "bool":
		return fmt.Sprintf("\t%s = false\n", expr)
	default:
		// пробуем вызвать Reset()
		return fmt.Sprintf(
			"\tif r, ok := any(%s).(interface{ Reset() }); ok {\n\t\tr.Reset()\n\t}\n",
			expr,
		)
	}
}

func generateFieldReset(expr string, t ast.Expr) string {
	switch tt := t.(type) {

	case *ast.Ident:
		return zeroValue(expr, tt.Name)

	case *ast.ArrayType:
		if tt.Len == nil {
			return fmt.Sprintf("\t%s = %s[:0]\n", expr, expr)
		}

	case *ast.MapType:
		return fmt.Sprintf("\tclear(%s)\n", expr)

	case *ast.StarExpr:
		var b strings.Builder
		fmt.Fprintf(&b, "\tif %s != nil {\n", expr)
		b.WriteString(generateFieldReset("*"+expr, tt.X))
		b.WriteString("\t}\n")
		return b.String()

	case *ast.SelectorExpr:
		// внешний тип — зануляем
		return fmt.Sprintf("\t%s = %s{}\n", expr, expr)
	}

	return ""
}

func generateReset(typeName string, st *ast.StructType) string {
	var b bytes.Buffer

	fmt.Fprintf(&b, "func (s *%s) Reset() {\n", typeName)
	b.WriteString("\tif s == nil {\n\t\treturn\n\t}\n\n")

	for _, field := range st.Fields.List {
		if len(field.Names) == 0 {
			continue
		}
		name := field.Names[0].Name
		b.WriteString(generateFieldReset("s."+name, field.Type))
	}

	b.WriteString("}\n\n")
	return b.String()
}

func main() {
	root, err := os.Getwd()
	if err != nil {
		panic(err)
	}

	err = filepath.WalkDir(root, func(path string, d os.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if !d.IsDir() {
			return nil
		}

		// пропускаем служебные директории
		if strings.Contains(path, "/vendor") || strings.Contains(path, "/.git") {
			return filepath.SkipDir
		}

		processDir(path)
		return nil
	})

	if err != nil {
		panic(err)
	}
}

func processDir(dir string) {
	fset := token.NewFileSet()

	pkgs, err := parser.ParseDir(fset, dir, nil, parser.ParseComments)
	if err != nil || len(pkgs) == 0 {
		return
	}

	for _, pkg := range pkgs {
		var generated bytes.Buffer
		var found bool

		generated.WriteString("// Code generated by reset tool. DO NOT EDIT.\n")
		generated.WriteString("package " + pkg.Name + "\n\n")

		for _, file := range pkg.Files {
			for _, decl := range file.Decls {
				genDecl, ok := decl.(*ast.GenDecl)
				if !ok || genDecl.Tok != token.TYPE {
					continue
				}

				if !hasMarker(genDecl.Doc) {
					continue
				}

				for _, spec := range genDecl.Specs {
					ts, ok := spec.(*ast.TypeSpec)
					if !ok {
						continue
					}

					st, ok := ts.Type.(*ast.StructType)
					if !ok {
						continue
					}

					found = true
					generated.WriteString(generateReset(ts.Name.Name, st))
				}
			}
		}

		if found {
			out := filepath.Join(dir, "reset.gen.go")
			_ = os.WriteFile(out, generated.Bytes(), 0644)
		}
	}
}

func hasMarker(cg *ast.CommentGroup) bool {
	if cg == nil {
		return false
	}
	for _, c := range cg.List {
		if strings.Contains(c.Text, marker) {
			return true
		}
	}
	return false
}
